# generated by datamodel-codegen:
#   filename:  openapi.yml

from __future__ import annotations

from enum import Enum
from typing import Any, Literal, Optional, Union

from pydantic import BaseModel, Field, RootModel, confloat


class Address(RootModel[str]):
    root: str = Field(
        ...,
        description='An Ethereum public address.\n',
        examples=['0x0000000000000000000000000000000000000000'],
    )


class Token(RootModel[str]):
    root: str = Field(
        ...,
        description='An ERC20 token address.\n',
        examples=['0xDEf1CA1fb7FBcDC777520aa7f396b4E015F497aB'],
    )


class TokenAmount(RootModel[str]):
    root: str = Field(
        ...,
        description=(
            'Amount of an ERC20 token. 256 bit unsigned integer in decimal notation.\n'
        ),
        examples=['1234567890'],
    )


class U256(RootModel[str]):
    root: str = Field(
        ...,
        description='256 bit unsigned integer in decimal notation.\n',
        examples=['1234567890'],
    )


class U128(RootModel[str]):
    root: str = Field(
        ...,
        description='128 bit unsigned integer in decimal notation.\n',
        examples=['1234567890'],
    )


class I128(RootModel[str]):
    root: str = Field(
        ...,
        description='128 bit signed integer in decimal notation.\n',
        examples=['-1234567890'],
    )


class I32(RootModel[float]):
    root: float = Field(
        ...,
        description='32 bit signed integer in decimal notation.\n',
        examples=[-12345],
    )


class BalancerPoolId(RootModel[str]):
    root: str = Field(
        ...,
        description=(
            'A hex-encoded 32 byte string containing the pool address (0..20), the pool'
            ' specialization (20..22) and the poolnonce (22..32).\n'
        ),
        examples=['0xc88c76dd8b92408fe9bea1a54922a31e232d873c0002000000000000000005b2'],
    )


class BigInt(RootModel[str]):
    root: str = Field(
        ...,
        description='An arbitrary-precision integer value.\n',
        examples=['1234567890'],
    )


class Decimal(RootModel[str]):
    root: str = Field(
        ..., description='An arbitrary-precision decimal value.\n', examples=['13.37']
    )


class NativePrice(RootModel[str]):
    root: str = Field(
        ...,
        description=(
            'The price in wei of the native token (Ether on Mainnet for example)'
            ' to\nbuy 10**18 of a token.\n'
        ),
        examples=['1234567890'],
    )


class DateTime(RootModel[str]):
    root: str = Field(
        ...,
        description='An ISO-8601 formatted date-time.',
        examples=['1970-01-01T00:00:00.000Z'],
    )


class TokenInfo(BaseModel):
    """
    Information about a token relevant to the auction.

    """

    decimals: Optional[int] = Field(
        None,
        description=(
            "The ERC20.decimals value for this token. This may be missing for\nERC20"
            " tokens that don't implement the optional metadata extension.\n"
        ),
    )
    symbol: Optional[str] = Field(
        None,
        description=(
            "The ERC20.symbol value for this token. This may be missing for"
            " ERC20\ntokens that don't implement the optional metadata extension.\n"
        ),
    )
    reference_price: Optional[NativePrice] = Field(
        None,
        alias='referencePrice',
        description=(
            'The reference price of this token for the auction used for scoring.\nThis'
            ' price is only included for tokens for which there are CoW\nProtocol'
            ' orders.\n'
        ),
    )
    available_balance: TokenAmount = Field(
        ...,
        alias='availableBalance',
        description=(
            'The balance held by the Settlement contract that is available\nduring a'
            ' settlement.\n'
        ),
    )
    trusted: bool = Field(
        ...,
        description=(
            'A flag which indicates that solvers are allowed to perform gas'
            ' cost\noptimizations for this token by not routing the trades via an'
            ' AMM,\nand instead use its available balances, as specified by CIP-2.\n'
        ),
    )


class Asset(BaseModel):
    """
    A token address with an amount.

    """

    token: Token
    amount: TokenAmount


class OrderUid(RootModel[str]):
    root: str = Field(
        ...,
        description=(
            "Unique identifier for the order. Order UIDs are 56 bytes long,"
            " where\nbytes [0, 32) represent the order digest used for signing,"
            " bytes\n[32, 52) represent the owner address and bytes [52, 56) represent"
            " the\norder's `validTo` field.\n"
        ),
        examples=[
            '0x30cff40d9f60caa68a37f0ee73253ad6ad72b45580c945fe3ab67596476937197854163b1b0d24e77dca702b97b5cc33e0f83dcb626122a6'
        ],
    )


class OrderKind(Enum):
    """
    The trading side of the order.

    """

    sell = 'sell'
    buy = 'buy'


class OrderClass(Enum):
    """
    How the CoW Protocol order was classified.

    """

    market = 'market'
    limit = 'limit'


class AppData(RootModel[Any]):
    root: Any = Field(
        ...,
        description=(
            '32 bytes of arbitrary application specific data that can be added to'
            ' an\norder. This can also be used to ensure uniqueness between two'
            ' orders\nwith otherwise the exact same parameters.\n'
        ),
        examples=['0x0000000000000000000000000000000000000000000000000000000000000000'],
    )


class FlashloanHint(BaseModel):
    """
    Contains information to hint at how to make use of flashloans to settle the associated order.

    """

    lender: Address = Field(
        ..., description='Which contract to request the flashloan from.'
    )
    borrower: Address = Field(
        ...,
        description=(
            'Who should receive the borrowed tokens. If this is not set the order owner'
            ' will get the tokens.\n'
        ),
    )
    token: Token = Field(..., description='Which token to flashloan.')
    amount: TokenAmount = Field(..., description='How much of the token to flashloan.')


class Flashloan(BaseModel):
    """
    Contains information about a flashloan for the solver's solution.

    """

    lender: Address
    borrower: Address
    token: Token
    amount: TokenAmount


class SellTokenBalance(Enum):
    """
    Where should the sell token be drawn from?

    """

    erc20 = 'erc20'
    internal = 'internal'
    external = 'external'


class BuyTokenBalance(Enum):
    """
    Where should the buy token be transferred to?

    """

    erc20 = 'erc20'
    internal = 'internal'


class SigningScheme(Enum):
    """
    How was the order signed?

    """

    eip712 = 'eip712'
    eth_sign = 'ethSign'
    pre_sign = 'preSign'
    eip1271 = 'eip1271'


class Signature(RootModel[str]):
    root: str = Field(
        ...,
        description='Signature bytes.\n',
        examples=[
            '0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
        ],
    )


class SurplusFee(BaseModel):
    """
    If the order receives more than limit price, pay the protocol a factor of the difference.

    """

    kind: Optional[Literal['surplus']] = None
    max_volume_factor: Optional[confloat(ge=0.0, le=0.99999)] = Field(
        None,
        alias='maxVolumeFactor',
        description='Never charge more than that percentage of the order volume.',
        examples=[0.05],
    )
    factor: Optional[float] = Field(
        None,
        description=(
            'The factor of the user surplus that the protocol will request from the'
            ' solver after settling the order\n'
        ),
        examples=[0.5],
    )


class VolumeFee(BaseModel):
    kind: Optional[Literal['volume']] = None
    factor: Optional[float] = Field(
        None,
        description=(
            "The fraction of the order's volume that the protocol will request from the"
            " solver after settling the order.\n"
        ),
        examples=[0.5],
    )


class Quote(BaseModel):
    sell_amount: Optional[TokenAmount] = None
    buy_amount: Optional[TokenAmount] = None
    fee: Optional[TokenAmount] = None


class TokenReserve(BaseModel):
    """
    A reserve of tokens in an on-chain liquidity pool.

    """

    balance: TokenAmount


class ConstantProductPool(BaseModel):
    """
    A UniswapV2-like constant product liquidity pool for a token pair.

    """

    kind: Literal['constantProduct']
    tokens: dict[str, TokenReserve] = Field(
        ..., description='A mapping of token address to its reserve amounts.\n'
    )
    fee: Decimal
    router: Address


class Tokens(TokenReserve):
    scaling_factor: Optional[Decimal] = Field(None, alias='scalingFactor')
    weight: Decimal


class Version(Enum):
    v0 = 'v0'
    v3_plus = 'v3Plus'


class WeightedProductPool(BaseModel):
    """
    A Balancer-like weighted product liquidity pool of N tokens.

    """

    kind: Literal['weightedProduct']
    tokens: dict[str, Tokens] = Field(
        ...,
        description='A mapping of token address to its reserve amounts with weights.\n',
    )
    fee: Decimal
    version: Optional[Version] = None
    balancer_pool_id: BalancerPoolId


class Tokens1(TokenReserve):
    scaling_factor: Decimal = Field(..., alias='scalingFactor')


class StablePool(BaseModel):
    """
    A Curve-like stable pool of N tokens.

    """

    kind: Literal['stable']
    tokens: dict[str, Tokens1] = Field(
        ...,
        description='A mapping of token address to token balance and scaling rate.\n',
    )
    amplification_parameter: Decimal = Field(..., alias='amplificationParameter')
    fee: Decimal
    balancer_pool_id: BalancerPoolId


class ConcentratedLiquidityPool(BaseModel):
    """
    A UniswapV3-like concentrated liquidity pool of 2 tokens.

    """

    kind: Literal['concentratedLiquidity']
    tokens: list[Token]
    sqrt_price: U256 = Field(..., alias='sqrtPrice')
    liquidity: U128
    tick: I32
    liquidity_net: dict[str, I128] = Field(
        ...,
        alias='liquidityNet',
        description='A map of tick indices to their liquidity values.\n',
    )
    fee: Decimal
    router: Address


class ForeignLimitOrder(BaseModel):
    """
    A 0x-like limit order external to CoW Protocol.

    """

    kind: Literal['limitOrder']
    maker_token: Token = Field(..., alias='makerToken')
    taker_token: Token = Field(..., alias='takerToken')
    maker_amount: TokenAmount = Field(..., alias='makerAmount')
    taker_amount: TokenAmount = Field(..., alias='takerAmount')
    taker_token_fee_amount: TokenAmount = Field(..., alias='takerTokenFeeAmount')


class LiquidityParameters(
    RootModel[
        Union[
            ConstantProductPool,
            WeightedProductPool,
            StablePool,
            ConcentratedLiquidityPool,
            ForeignLimitOrder,
        ]
    ]
):
    root: Union[
        ConstantProductPool,
        WeightedProductPool,
        StablePool,
        ConcentratedLiquidityPool,
        ForeignLimitOrder,
    ]


class Liquidity(BaseModel):
    """
    On-chain liquidity that can be used in a solution. This liquidity is
    provided to facilitate onboarding new solvers. Additional liquidity that
    is not included in this set may still be used in solutions.

    """

    id: str = Field(
        ...,
        description=(
            'An opaque ID used for uniquely identifying the liquidity within\na single'
            ' auction (note that they are **not** guaranteed to be\nunique across'
            ' auctions). This ID is used in the solution for\nmatching interactions'
            ' with the executed liquidity.\n'
        ),
    )
    address: Address = Field(
        ...,
        description=(
            'The Ethereum public address of the liquidity. The actual address\nthat is'
            ' specified is dependent on the kind of liquidity.\n'
        ),
    )
    gas_estimate: BigInt = Field(
        ...,
        alias='gasEstimate',
        description=(
            'A rough approximation of gas units required to use this\nliquidity'
            ' on-chain.\n'
        ),
    )


class JitOrder(BaseModel):
    """
    A just-in-time liquidity order included in a settlement. These will
    be assumed to be fill-or-kill orders with a signed fee of 0.

    """

    sell_token: Token = Field(..., alias='sellToken')
    buy_token: Token = Field(..., alias='buyToken')
    receiver: Address
    sell_amount: TokenAmount = Field(..., alias='sellAmount')
    buy_amount: TokenAmount = Field(..., alias='buyAmount')
    valid_to: int = Field(..., alias='validTo')
    app_data: AppData = Field(..., alias='appData')
    kind: OrderKind
    partially_fillable: Optional[bool] = Field(None, alias='partiallyFillable')
    sell_token_balance: SellTokenBalance = Field(..., alias='sellTokenBalance')
    buy_token_balance: BuyTokenBalance = Field(..., alias='buyTokenBalance')
    signing_scheme: SigningScheme = Field(..., alias='signingScheme')
    signature: Signature


class Fulfillment(BaseModel):
    """
    A trade which fulfills an order from the auction.

    """

    kind: Literal['fulfillment']
    order: OrderUid = Field(
        ...,
        description=(
            'A reference by UID of the order to execute in a solution. The order\nmust'
            ' be included in the auction input.\n'
        ),
    )
    fee: Optional[Any] = Field(
        None,
        description=(
            'The sell token amount that should be taken as a fee for this\ntrade. This'
            ' only gets returned for limit orders and only refers\nto the actual amount'
            ' filled by the trade.\n'
        ),
    )
    executed_amount: TokenAmount = Field(
        ...,
        alias='executedAmount',
        description=(
            'The amount of the order that was executed. This is denoted in\n"sellToken"'
            ' for sell orders, and "buyToken" for buy orders.\n'
        ),
    )


class JitTrade(BaseModel):
    """
    A trade with a JIT order.

    """

    kind: Literal['jit']
    executed_amount: TokenAmount = Field(
        ...,
        alias='executedAmount',
        description=(
            'The amount of the order that was executed. This is denoted in\n"sellToken"'
            ' for sell orders, and "buyToken" for buy orders.\n'
        ),
    )
    fee: TokenAmount = Field(
        ...,
        description=(
            'The amount of sell token which should be kept to cover the gas\ncost for'
            ' this JIT trade. If a fee is set on a sell order the\n"executedAmount"'
            ' needs to be reduced accordingly to not "overfill"\nthe order.\n'
        ),
    )
    order: JitOrder = Field(
        ..., description='The just-in-time liquidity order to execute in a solution.\n'
    )


class Trade(RootModel[Union[Fulfillment, JitTrade]]):
    root: Union[Fulfillment, JitTrade] = Field(
        ..., description='A trade for a CoW Protocol order included in a solution.\n'
    )


class LiquidityInteraction(BaseModel):
    """
    Interaction representing the execution of liquidity that was passed in
    with the auction.

    """

    kind: Literal['liquidity']
    id: float = Field(
        ..., description='The ID of executed liquidity provided in the auction input.\n'
    )
    input_token: Token = Field(..., alias='inputToken')
    output_token: Token = Field(..., alias='outputToken')
    input_amount: TokenAmount = Field(..., alias='inputAmount')
    output_amount: TokenAmount = Field(..., alias='outputAmount')


class Allowance(BaseModel):
    """
    An ERC20 allowance from the settlement contract to some spender that is
    required for a custom interaction.

    """

    token: Token
    spender: Address
    amount: Optional[TokenAmount] = None


class CustomInteraction(BaseModel):
    """
    A searcher-specified custom interaction to be included in the final
    settlement.

    """

    kind: Literal['custom']
    target: Address
    value: TokenAmount
    call_data: str = Field(
        ...,
        alias='callData',
        description='The EVM calldata bytes.\n',
        examples=['0x01020304'],
    )
    allowances: Optional[list[Allowance]] = Field(
        None,
        description='ERC20 allowances that are required for this custom interaction.\n',
    )
    inputs: list[Asset]
    outputs: list[Asset]


class Interaction1(BaseModel):
    """
    An interaction to execute as part of a settlement.

    """

    internalize: Optional[bool] = Field(
        None,
        description=(
            'A flag indicating that the interaction should be "internalized",\nas'
            ' specified by CIP-2.\n'
        ),
    )


class Interaction2(LiquidityInteraction, Interaction1):
    """
    An interaction to execute as part of a settlement.

    """


class Interaction3(CustomInteraction, Interaction1):
    """
    An interaction to execute as part of a settlement.

    """


class Interaction(RootModel[Union[Interaction2, Interaction3]]):
    """
    An interaction to execute as part of a settlement.

    """

    root: Union[Interaction2, Interaction3] = Field(
        ..., description='An interaction to execute as part of a settlement.\n'
    )


class InteractionData(BaseModel):
    target: Optional[Address] = None
    value: Optional[TokenAmount] = None
    call_data: Optional[str] = Field(
        None, alias='callData', description='Hex encoded bytes with `0x` prefix.'
    )


class CallData(RootModel[str]):
    root: str = Field(
        ...,
        description=(
            'Some `calldata` sent to a contract in a transaction encoded as a hex with'
            ' `0x` prefix.\n'
        ),
        examples=['0xca11da7a'],
    )


class PriceImprovement(BaseModel):
    """
    A cut from the price improvement over the best quote is taken as a protocol fee.

    """

    kind: Optional[Literal['priceImprovement']] = None
    max_volume_factor: Optional[float] = Field(
        None,
        alias='maxVolumeFactor',
        description='Never charge more than that percentage of the order volume.',
        examples=[0.01],
    )
    factor: Optional[float] = Field(
        None,
        description=(
            'The factor of the user surplus that the protocol will request from the'
            ' solver after settling the order\n'
        ),
        examples=[0.5],
    )
    quote: Optional[Quote] = None


class Call(BaseModel):
    target: Optional[Address] = None
    value: Optional[TokenAmount] = None
    call_data: Optional[list[CallData]] = Field(
        None,
        alias='callData',
        description='The call data to be used for the interaction.',
    )


class FeePolicy(RootModel[Union[SurplusFee, PriceImprovement, VolumeFee]]):
    root: Union[SurplusFee, PriceImprovement, VolumeFee] = Field(
        ..., description='A fee policy that applies to an order.\n'
    )


class Solution(BaseModel):
    """
    A computed solution for a given auction.

    """

    id: float = Field(
        ...,
        description=(
            'An opaque identifier for the solution. This is a solver generated number'
            ' that is unique across multiple solutions within the auction.\n'
        ),
    )
    prices: dict[str, U256] = Field(
        ...,
        description=(
            'A clearing price map of token address to price. The price can'
            ' have\narbitrary denomination.\n'
        ),
    )
    trades: list[Trade] = Field(
        ..., description='CoW Protocol order trades included in the solution.\n'
    )
    pre_interactions: Optional[list[Call]] = Field(
        None,
        alias='preInteractions',
        description='Interactions to encode before a settlement.\n',
    )
    interactions: list[Interaction] = Field(
        ..., description='Interactions to encode within a settlement.\n'
    )
    post_interactions: Optional[list[Call]] = Field(
        None,
        alias='postInteractions',
        description='Interactions to encode after a settlement.\n',
    )
    gas: Optional[int] = Field(
        None, description='How many units of gas this solution is estimated to cost.'
    )
    flashloans: Optional[dict[str, Flashloan]] = Field(
        None,
        description=(
            "Flashloans that are provided for this solution, mapping order UIDs to"
            " flashloan details.\nIn case of the field absense, the driver will use the"
            " order's flashloan hint originally defined by the user.\n"
        ),
    )


class Order(BaseModel):
    """
    CoW Protocol order information relevant to execution.

    """

    uid: OrderUid
    sell_token: Token = Field(..., alias='sellToken')
    buy_token: Token = Field(..., alias='buyToken')
    sell_amount: TokenAmount = Field(..., alias='sellAmount')
    full_sell_amount: Optional[TokenAmount] = Field(None, alias='fullSellAmount')
    buy_amount: TokenAmount = Field(..., alias='buyAmount')
    full_buy_amount: TokenAmount = Field(..., alias='fullBuyAmount')
    fee_policies: Optional[list[FeePolicy]] = Field(
        None,
        alias='feePolicies',
        description='Any protocol fee policies that apply to the order.\n',
    )
    valid_to: int = Field(..., alias='validTo')
    kind: OrderKind
    receiver: Optional[Address] = None
    owner: Address
    partially_fillable: bool = Field(
        ...,
        alias='partiallyFillable',
        description=(
            'Whether or not this order can be partially filled. If this is false,\nthen'
            ' the order is a "fill-or-kill" order, meaning it needs to be\ncompletely'
            ' filled or not at all.\n'
        ),
    )
    pre_interactions: list[Interaction] = Field(..., alias='preInteractions')
    post_interactions: list[InteractionData] = Field(..., alias='postInteractions')
    sell_token_source: SellTokenBalance = Field(..., alias='sellTokenSource')
    buy_token_destination: BuyTokenBalance = Field(..., alias='buyTokenDestination')
    class_: OrderClass = Field(..., alias='class')
    app_data: AppData = Field(..., alias='appData')
    flashloan_hint: Optional[FlashloanHint] = Field(None, alias='flashloanHint')
    signing_scheme: SigningScheme = Field(..., alias='signingScheme')
    signature: Signature


class Auction(BaseModel):
    """
    The abstract auction to be solved by the searcher.

    """

    id: Optional[str] = Field(
        None,
        description=(
            'An opaque identifier for the auction. Will be set to `null` for\nrequests'
            ' that are not part of an auction (when quoting token prices\nfor'
            ' example).\n'
        ),
    )
    tokens: dict[str, TokenInfo] = Field(
        ..., description='A map of token addresses to token information.\n'
    )
    orders: list[Order] = Field(
        ..., description='The solvable orders included in the auction.\n'
    )
    liquidity: list[Liquidity] = Field(
        ..., description='On-chain liquidity that can be used by the solution.\n'
    )
    effective_gas_price: TokenAmount = Field(
        ...,
        alias='effectiveGasPrice',
        description=(
            "The current estimated gas price that will be paid when executing"
            " a\nsettlement. Additionally, this is the gas price that is"
            " multiplied\nwith a settlement's gas estimate for solution scoring.\n"
        ),
    )
    deadline: DateTime = Field(
        ...,
        description=(
            'The deadline by which a solution to the auction is required.\nRequests'
            ' that go beyond this deadline are expected to be cancelled\nby the'
            ' caller.\n'
        ),
    )
    surplus_capturing_jit_order_owners: list[Address] = Field(
        ...,
        alias='surplusCapturingJitOrderOwners',
        description=(
            'List of addresses on whose surplus will count towards the objective value'
            ' of their solution (unlike other orders that were created by the'
            ' solver).\n'
        ),
    )
